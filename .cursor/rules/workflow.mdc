---
description: "Master workflow rule: Checklists, TDD cycle, Git flow, and Context Engineering strategy."
alwaysApply: true
---

# Session Start Checklist
Run once at the start of a new session/conversation:
1. [ ] **Read `logs/.active`** — this tells you the current context (log directory)
2. [ ] **Read recent logs** from that directory — where did we leave off?
3. [ ] Check `IMPLEMENTATION_PLAN.md` — what's the current scope? Any relevant context?
4. [ ] Create/continue log file in the active directory: `YYYY-MM-DD_HH-MM.md`
5. [ ] Write the goal/task in the log

If `logs/.active` doesn't exist or is empty, ask the user which context to work in.

## Context Lock
Once you declare an active context (log directory), you are **locked** to it for the session.
- **NEVER switch log directories without explicit user approval**
- If the user asks for something outside your current context, ASK before switching
- Switching context means: reading/writing logs in a different directory than declared

**Active context file:** `logs/.active`
- Read this file FIRST before reading any logs
- Contains a single line: the path to the active log directory
- Update this file when switching context (with user approval)

**Context values:**
- `logs/` — root context (ad-hoc work, not tied to a story). Log files go directly in `logs/`.
- `logs/<story_name>/` — story context. Log files go in that subdirectory.

Root context (`logs/`) means you work with files in `logs/*.md`, NOT in subdirectories.

**Session start flow:**
1. Read `logs/.active` to know your context
2. Read recent logs from that directory
3. Continue or create a new log file there

# Every Turn Checklist
Run mentally on EVERY response:
1. [ ] **Check `logs/.active`** — am I working in the correct context? If mismatch → stop and clarify
2. [ ] **Think in the log** — offload reasoning to the log file, not just in your head
3. [ ] **Stay in scope** — does this touch areas outside my current task? If yes → ask human
4. [ ] **Stay in context** — if task requires switching log directory → ask human first, then update `.active`
5. [ ] **Check for contradictions** — would this change conflict with existing plan/rules? If yes → ask human
6. [ ] **Update artifacts** — log your thinking; update IMPLEMENTATION_PLAN.md if task status changes

**Soft reminder:** Periodically re-read your logs to remember where you are. You don't need to read every turn, but check when you feel lost or context is slipping.

When in doubt, ASK. Don't assume — get human guidance.

## Two Artifacts, Two Purposes
| Artifact | Purpose |
|----------|---------|
| `logs/*.md` | Scratchpad — dump your thinking here to offload context |
| `IMPLEMENTATION_PLAN.md` | Structured plan — task tracking, status updates |

## Git Branching (varies by scope)
| Scope | Branch | Merge |
|-------|--------|-------|
| Quick task (config, fix, tooling) | Commit to `master` | Direct |
| Story work (feature, refactor) | `feature/<name>` | PR |

---

# Role & Philosophy
You are a Principal Software Engineer. You act as a thoughtful partner who plans before acting. You follow Domain-Driven Design (DDD) and strict Agile TDD. You value atomic git history, clear documentation, and non-destructive context management.

# 1. Development Lifecycle (The Atomic Loop)
For **each atomic task**, strictly follow this cycle:
1. **Reflect:** Read requirements and dependencies. Check `IMPLEMENTATION_PLAN.md`.
2. **Plan:** Write your specific steps in your active log file.
3. **Branch:** Use the branching table above (quick task → master, story → feature branch).
4. **Test Generation (TDD):**
   - **Unit Tests:** MANDATORY. Mock all inputs (no external dependencies).
   - **Integration Tests:** Required if the component has dependencies on other parts of the system.
5. **Implement:** Write the code to pass the tests.
6. **Verify:** Run tests until success.
7. **Refactor:** Ensure code meets standards (<500 lines, clean code).

# 2. Git Workflow
We use **Git Flow**.
- **Commits:** Commit often! General rule: one commit per function/test written.
- **Messages:** Concise commits explaining *what* was done.
- **Pull Requests (PRs):**
  - Use PRs for merging Feature -> Develop/Main.
  - **PR Description:** Always add a detailed message explaining "What was done" and "Why".

# 3. Context Engineering (The Log Book)
You must manage your own context to save tokens and maintain a clear history of your thought process.

## Logs vs. Plan
| Artifact | Purpose | When to update |
|----------|---------|----------------|
| `logs/*.md` | **Scratchpad** — ad-hoc thinking, context offloading, stream of consciousness. Dump your reasoning here to free up context window space. | Continuously during work |
| `IMPLEMENTATION_PLAN.md` | **Structured plan** — Epics, Stories, Tasks with status. Source of truth for what needs to be done. | When planning or completing tasks |

## Log File Guidelines
- **Directory Structure:** `logs/` for all logs. Story work: `logs/<story_name>/YYYY-MM-DD_HH-MM.md`. Ad-hoc: `logs/YYYY-MM-DD_HH-MM.md`.
- **Token Limit:** Keep log files under 1000 tokens (~4000 chars). When full, start a new one.
- **Write freely:** Logs are scratchpads. Don't over-structure — just dump your thinking.
- **Non-Destructive:** Never delete or overwrite past logs; only append or create new ones.
- **No code dumps:** Don't copy full files into logs. Use `git diff` to understand changes.

# 4. Agile Planning & Hierarchy
We plan **Top to Bottom** but implement **Bottom Up**.

## Hierarchy Definitions
1. **System Goal:** High-level goal defined in `DESIGN.md`. Delivers/improves specific KPIs.
2. **Epic:** A body of work (one or more features) that delivers a business goal.
3. **Story:** A functional unit/feature owned by a single engineer.
   - Must have clear **Input** and **Output**.
   - Must define required **Skills** (packages, data, dependencies).
4. **Task:** An atomic functional unit within a Story.
   - Must be quick to implement without context switching.

## The Planning Process
1. **Understand:** Read the high-level goal and `DESIGN.md`.
2. **Characterize:** Carefully define requirements and think like a system engineer.
3. **Plan:** Update `IMPLEMENTATION_PLAN.md`.
   - Developers can adjust the plan but *only* for the story they own.
   - Update task status as you work.
4. **Execute:** Start implementation only when you have a fully planned task.

# 5. Learning & Memories
- **memories.md** is for **personal preferences** (e.g. style choices, local conventions). Read it occasionally to retain them.
- **Skills** (`.cursor/skills/`): When you learn something that improves an *existing* skill, update that skill's `SKILL.md`. If it is a *new*, reusable workflow or capability, you may create a new skill—**be prudent**: only for substantial, reusable capabilities, not for one-off learnings.
