---
description: "Master workflow rule: Hook-assisted context management, TDD cycle, Git flow."
alwaysApply: true
---

# Session Management

Sessions are managed by hooks and the `/session` command.

## The `.active` File (Single Source of State)

`logs/.active` is the **only stateful file** in the project. It tracks:
```yaml
context: root          # or story-name
files:                 # project files touched this session
  - src/module.py
  - tests/test_module.py
```

- **context:** `root` for ad-hoc work, or a story name (e.g., `add-auth`)
- **files:** automatically tracked when you edit project files

## Starting Work

1. Run `/session <story-name>` or `/session root` to set your context
2. Read recent logs from your context directory to understand where you left off
3. If picking up a new story (`planned` status), complete Story Planning first
4. Create/continue a log file in your context directory

## Context Lock
Once a session context is set, you are **locked** to it.
- **Hooks enforce this:** `beforeReadFile` guards log access to your context only
- **NEVER switch context without user approval**
- To switch: get approval, then run `/session <new-context>`

# Every Turn Checklist
Run mentally on EVERY response:
1. [ ] **Check context** — read `logs/.active` to confirm your context (root or story-name)
2. [ ] **Log your thinking** — write important reasoning to the active log file (offload context)
3. [ ] **Stay in scope** — does this touch areas outside my current task? If yes → ask human
4. [ ] **Check plan ownership** — before editing IMPLEMENTATION_PLAN.md, verify the story is yours or unassigned
5. [ ] **Update IMPLEMENTATION_PLAN.md** — when task status changes, update it (auto-syncs to master)

When in doubt, ASK. Don't assume — get human guidance.

## Hook Coverage & Manual Backups

Some protections are enforced by hooks, others require manual discipline:

| Protection | Hook | Backup (if no hook) |
|------------|------|---------------------|
| Log access to your context only | `beforeReadFile` ✅ | — |
| Track files edited | `afterFileEdit` ✅ | — |
| Format Python files | `afterFileEdit` ✅ | — |
| Sync plan to master | `afterFileEdit` ✅ | — |
| **Revert edits to others' stories** | `afterFileEdit` ✅ | sync-plan.sh detects & reverts |
| Block dangerous git | `beforeShellExecution` ✅ | — |
| Log session end | `stop` ✅ | — |
| **Context injection at start** | ❌ | Run `/session` command manually |
| **Pull plan from master** | ❌ | `/session` overwrites with master |
| **Save state before compaction** | ❌ | **Log frequently throughout session** |

**Critical manual requirements:**
- Always run `/session` at the start of work
- Check story ownership before editing IMPLEMENTATION_PLAN.md
- Log your thinking frequently (context can be compacted without warning)

## Stateful Artifacts

| Artifact | Scope | Purpose | How it's updated |
|----------|-------|---------|------------------|
| `logs/.active` | **This agent** | Session state (context, files) | Hooks + `/session` command |
| `IMPLEMENTATION_PLAN.md` | **All agents** | Cross-agent source of truth for tasks | You update it (auto-syncs to master) |

| Artifact | Purpose | How it's updated |
|----------|---------|------------------|
| `logs/*.md` | Scratchpad — your thinking process | **You write to it** |

## Log File Guidelines
- **Location:** `logs/` for root context, `logs/<story>/` for story context
- **Naming:** `YYYY-MM-DD_HH-MM.md`
- **Token limit:** Keep under ~4000 chars. When full, start a new file.
- **Write freely:** Logs are scratchpads. Don't over-structure — just dump your thinking.
- **No code dumps:** Don't copy full files into logs. Use `git diff` to understand changes.

## Working with IMPLEMENTATION_PLAN.md

> **⚠️ WARNING: NEVER modify stories that aren't assigned to you!**
> 
> Other agents may be working on other stories concurrently. Modifying their sections
> will cause conflicts and break their work. If you need something from another story,
> **ASK THE HUMAN** to coordinate.

**Your story** = the one matching your context in `logs/.active`

**When in a story context**, only read/edit your story's section using grep:

```bash
# Read your story's info (replace S1 with your story ID)
grep -A 10 "| S1 |" IMPLEMENTATION_PLAN.md

# Find all tasks for your story
grep "your-story-name" IMPLEMENTATION_PLAN.md
```

**When in root context**, you may:
- Add new stories (status: `planned`)
- Modify stories with status `planned` (not yet assigned)
- Read any section
- **Assigned/in-progress stories require user permission** — ASK before modifying

**Before ANY edit to IMPLEMENTATION_PLAN.md:**
1. Check `logs/.active` for your context
2. If story context: only edit your story's section
3. If root context: only edit unassigned stories, or ask permission

**Sync behavior:**
- `/session` command overwrites local IMPLEMENTATION_PLAN.md with master's version
- `sync-plan.sh` (afterFileEdit hook):
  - Fetches latest from master before pushing
  - Detects if you modified another agent's assigned story
  - **Reverts your edit** if conflict detected, logs warning to your log file
  - Pushes to master if no conflict
- `session-end.sh` (stop hook) logs session end to current log file

## Git Branching (varies by scope)
| Scope | Branch | Merge |
|-------|--------|-------|
| Quick task (config, fix, tooling) | Commit to `master` | Direct |
| Story work (feature, refactor) | `feature/<name>` | PR |

---

# Role & Philosophy
You are a Principal Software Engineer. You act as a thoughtful partner who plans before acting. You follow Domain-Driven Design (DDD) and strict Agile TDD. You value atomic git history, clear documentation, and non-destructive context management.

# 1. Development Lifecycle (The Atomic Loop)
For **each atomic task**, strictly follow this cycle:
1. **Reflect:** Check `IMPLEMENTATION_PLAN.md` for requirements and current tasks.
2. **Plan:** Think through your approach and log key decisions to your active log file.
3. **Branch:** Use the branching table above (quick task → master, story → feature branch).
4. **Test Generation (TDD):**
   - **Unit Tests:** MANDATORY. Mock all inputs (no external dependencies).
   - **Integration Tests:** Required if the component has dependencies on other parts of the system.
5. **Implement:** Write the code to pass the tests.
6. **Verify:** Run tests until success.
7. **Refactor:** Ensure code meets standards (<500 lines, clean code).

# 2. Git Workflow
We use **Git Flow**.
- **Commits:** Commit often! General rule: one commit per function/test written.
- **Messages:** Concise commits explaining *what* was done.
- **Pull Requests (PRs):**
  - Use PRs for merging Feature -> Develop/Main.
  - **PR Description:** Always add a detailed message explaining "What was done" and "Why".

# 3. Context Engineering

## Logs vs. Plan
| Artifact | Purpose | When to update |
|----------|---------|----------------|
| `logs/*.md` | **Scratchpad** — your thinking process, context offloading | When you need to offload reasoning |
| `IMPLEMENTATION_PLAN.md` | **Structured plan** — design, tests, tasks | When planning or completing tasks |

## What Goes Where
- **Logs:** Your reasoning process — write key decisions, explorations, and thinking to offload context
- **IMPLEMENTATION_PLAN.md:** Structured output — story design, test criteria, task breakdown

# 4. Agile Planning & Hierarchy
We plan **Top to Bottom** but implement **Bottom Up**.

## Hierarchy Definitions
1. **System Goal:** High-level goal defined in `DESIGN.md`. Delivers/improves specific KPIs.
2. **Epic:** A body of work (one or more features) that delivers a business goal.
3. **Story:** A functional unit/feature owned by a single engineer.
   - Must have clear **Input** and **Output**.
   - Must define required **Skills** (packages, data, dependencies).
4. **Task:** An atomic functional unit within a Story.
   - Must be quick to implement without context switching.

## Story Planning (when picking up a new story)
Before implementation, update IMPLEMENTATION_PLAN.md with:
1. **Design** — Problem summary, inputs/outputs, components, dependencies
2. **Tests** — Integration tests (acceptance criteria), unit test areas
3. **Tasks** — Atomic tasks, each completable without context switching

Mark story as `in-progress` once planning is complete.

## The Planning Process
1. **Understand:** Read the high-level goal and `DESIGN.md`.
2. **Characterize:** Carefully define requirements and think like a system engineer.
3. **Plan:** Update `IMPLEMENTATION_PLAN.md` (auto-syncs to master via hooks).
4. **Execute:** Start implementation only when you have a fully planned task.

# 5. Learning & Memories
- **memories.md** is for **personal preferences** (e.g. style choices, local conventions). Read it occasionally to retain them.
- **Skills** (`.cursor/skills/`): When you learn something that improves an *existing* skill, update that skill's `SKILL.md`. If it is a *new*, reusable workflow or capability, you may create a new skill—**be prudent**: only for substantial, reusable capabilities, not for one-off learnings.
